"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getLatestVersion = exports.getDependencies = exports.detectYarn = void 0;
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const cp = __importStar(require("child_process"));
const find_yarn_workspace_root_1 = __importDefault(require("find-yarn-workspace-root"));
const package_1 = require("./package");
const util_1 = require("./util");
const exists = (file) => fs.promises.stat(file).then(_ => true, _ => false);
function parseStdout({ stdout }) {
    return stdout.split(/[\r\n]/).filter(line => !!line)[0];
}
function exec(command, options = {}, cancellationToken) {
    return new Promise((c, e) => {
        let disposeCancellationListener = null;
        const child = cp.exec(command, { ...options, encoding: 'utf8' }, (err, stdout, stderr) => {
            if (disposeCancellationListener) {
                disposeCancellationListener();
                disposeCancellationListener = null;
            }
            if (err) {
                return e(err);
            }
            c({ stdout, stderr });
        });
        if (cancellationToken) {
            disposeCancellationListener = cancellationToken.subscribe((err) => {
                child.kill();
                e(err);
            });
        }
    });
}
async function checkNPM(cancellationToken) {
    const { stdout } = await exec('npm -v', {}, cancellationToken);
    const version = stdout.trim();
    if (/^3\.7\.[0123]$/.test(version)) {
        throw new Error(`npm@${version} doesn't work with vsce. Please update npm: npm install -g npm`);
    }
}
function getNpmDependencies(cwd) {
    return checkNPM()
        .then(() => exec('npm list --production --parseable --depth=99999 --loglevel=error', { cwd, maxBuffer: 5000 * 1024 }))
        .then(({ stdout }) => stdout.split(/[\r\n]/).filter(dir => path.isAbsolute(dir))
        .map(dir => {
        return {
            src: dir,
            dest: path.relative(cwd, dir)
        };
    }));
}
async function asYarnDependencies(root, rootDependencies) {
    const resolve = async (prefix, dependencies, collected = new Map()) => await Promise.all(dependencies
        .map(async (name) => {
        let newPrefix = prefix, depPath = null, depManifest = null;
        while (!depManifest && root.length <= newPrefix.length) {
            depPath = path.join(newPrefix, 'node_modules', name);
            try {
                depManifest = await (0, package_1.readNodeManifest)(depPath);
            }
            catch (err) {
                newPrefix = path.join(newPrefix, '..');
                if (newPrefix.length < root.length) {
                    throw err;
                }
            }
        }
        if (!depPath || !depManifest) {
            throw new Error(`Error finding dependencies`);
        }
        const result = {
            name,
            path: {
                src: depPath,
                dest: path.relative(root, depPath),
            },
            children: [],
        };
        const shouldResolveChildren = !collected.has(depPath);
        collected.set(depPath, result);
        if (shouldResolveChildren) {
            result.children = await resolve(depPath, Object.keys(depManifest.dependencies || {}), collected);
        }
        return result;
    }));
    return resolve(root, rootDependencies);
}
function selectYarnDependencies(deps, packagedDependencies) {
    const index = new (class {
        constructor() {
            this.data = Object.create(null);
            for (const dep of deps) {
                if (this.data[dep.name]) {
                    throw Error(`Dependency seen more than once: ${dep.name}`);
                }
                this.data[dep.name] = dep;
            }
        }
        find(name) {
            let result = this.data[name];
            if (!result) {
                throw new Error(`Could not find dependency: ${name}`);
            }
            return result;
        }
    })();
    const reached = new (class {
        constructor() {
            this.values = [];
        }
        add(dep) {
            if (this.values.indexOf(dep) < 0) {
                this.values.push(dep);
                return true;
            }
            return false;
        }
    })();
    const visit = (name) => {
        let dep = index.find(name);
        if (!reached.add(dep)) {
            // already seen -> done
            return;
        }
        for (const child of dep.children) {
            visit(child.name);
        }
    };
    packagedDependencies.forEach(visit);
    return reached.values;
}
async function getYarnProductionDependencies(root, manifest, packagedDependencies) {
    const usingPackagedDependencies = Array.isArray(packagedDependencies);
    let result = await asYarnDependencies(root, Object.keys(manifest.dependencies || {}));
    if (usingPackagedDependencies) {
        result = selectYarnDependencies(result, packagedDependencies);
    }
    return result;
}
async function getYarnDependencies(cwd, root, manifest, packagedDependencies) {
    const result = [{
            src: cwd,
            dest: ''
        }];
    if (await exists(path.join(root, 'yarn.lock'))) {
        const deps = await getYarnProductionDependencies(root, manifest, packagedDependencies);
        const flatten = (dep) => {
            result.push(dep.path);
            dep.children.forEach(flatten);
        };
        deps.forEach(flatten);
    }
    const dedup = new Map();
    for (const item of result) {
        if (!dedup.has(item.src)) {
            dedup.set(item.src, item);
        }
    }
    return [...dedup.values()];
}
async function detectYarn(root) {
    for (const name of ['yarn.lock', '.yarnrc', '.yarnrc.yaml', '.pnp.cjs', '.yarn']) {
        if (await exists(path.join(root, name))) {
            if (!process.env['VSCE_TESTS']) {
                util_1.log.info(`Detected presence of ${name}. Using 'yarn' instead of 'npm' (to override this pass '--no-yarn' on the command line).`);
            }
            return true;
        }
    }
    return false;
}
exports.detectYarn = detectYarn;
async function getDependencies(cwd, manifest, dependencies, packagedDependencies) {
    const root = (0, find_yarn_workspace_root_1.default)(cwd) || cwd;
    if (dependencies === 'none') {
        return [{ src: root, dest: '' }];
    }
    else if (dependencies === 'yarn' || (dependencies === undefined && (await detectYarn(root)))) {
        return await getYarnDependencies(cwd, root, manifest, packagedDependencies);
    }
    else {
        return await getNpmDependencies(cwd);
    }
}
exports.getDependencies = getDependencies;
function getLatestVersion(name, cancellationToken) {
    return checkNPM(cancellationToken)
        .then(() => exec(`npm show ${name} version`, {}, cancellationToken))
        .then(parseStdout);
}
exports.getLatestVersion = getLatestVersion;
//# sourceMappingURL=npm.js.map